<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <link href="/../deepseek.css" rel="stylesheet">

</head>
<body>
<div class="ds-markdown ds-markdown--block" style="--ds-md-zoom: 1.143;"><p>Индексы — это структуры данных, которые
    используются в базах данных для ускорения поиска и извлечения данных из таблиц. Они работают аналогично оглавлению в
    книге, позволяя быстро находить нужные данные без полного сканирования таблицы. В разных СУБД (например, MySQL,
    PostgreSQL, Oracle) поддерживаются различные типы индексов. Ниже приведены основные типы индексов, которые
    встречаются в большинстве СУБД.</p>
    <hr>
    <h3><strong>Основные типы индексов</strong></h3>
    <ol start="1">
        <li><p><strong>B-дерево (B-Tree):</strong></p>
            <ul>
                <li><p>Наиболее распространённый тип индекса.</p></li>
                <li><p>Поддерживает операции поиска, вставки, удаления и обновления за время O(log n).</p></li>
                <li><p>Подходит для точного поиска (например, <code>WHERE column = value</code>) и диапазонных запросов
                    (например, <code>WHERE column BETWEEN value1 AND value2</code>).</p></li>
                <li><p>Используется по умолчанию в большинстве СУБД.</p></li>
            </ul>
        </li>
        <li><p><strong>Хэш-индекс (Hash Index):</strong></p>
            <ul>
                <li><p>Использует хэш-функцию для быстрого поиска по точному совпадению.</p></li>
                <li><p>Эффективен для операций <code>WHERE column = value</code>, но не поддерживает диапазонные
                    запросы.</p></li>
                <li><p>Подходит для таблиц с большим количеством уникальных значений.</p></li>
                <li><p>Используется реже, чем B-дерево, так как имеет ограниченную функциональность.</p></li>
            </ul>
        </li>
        <li><p><strong>Составной индекс (Composite Index):</strong></p>
            <ul>
                <li><p>Индекс, созданный на нескольких столбцах.</p></li>
                <li><p>Полезен для запросов, которые фильтруют или сортируют по нескольким столбцам.</p></li>
                <li><p>Порядок столбцов в индексе важен: запросы должны использовать префикс индекса (например, индекс
                    на <code>(col1, col2)</code> будет полезен для запросов с <code>col1</code>, но не для запросов
                    только с <code>col2</code>).</p></li>
            </ul>
        </li>
        <li><p><strong>Уникальный индекс (Unique Index):</strong></p>
            <ul>
                <li><p>Гарантирует, что все значения в индексируемом столбце (или комбинации столбцов) уникальны.</p>
                </li>
                <li><p>Используется для обеспечения целостности данных, например, для первичных ключей (Primary
                    Key).</p></li>
            </ul>
        </li>
        <li><p><strong>Полнотекстовый индекс (Full-Text Index):</strong></p>
            <ul>
                <li><p>Используется для поиска по текстовым данным (например, по словам или фразам в больших
                    текстах).</p></li>
                <li><p>Поддерживает сложные запросы, такие как поиск по синонимам, морфологическому анализу и
                    релевантности.</p></li>
                <li><p>Часто используется в поисковых системах и приложениях, работающих с текстовыми данными.</p></li>
            </ul>
        </li>
        <li><p><strong>Пространственный индекс (Spatial Index):</strong></p>
            <ul>
                <li><p>Используется для работы с геопространственными данными (например, координаты, геометрические
                    фигуры).</p></li>
                <li><p>Поддерживает операции, такие как поиск объектов в определённой области или вычисление
                    расстояний.</p></li>
                <li><p>Пример: индекс для столбцов с типом <code>GEOMETRY</code> или <code>GEOGRAPHY</code> в
                    PostgreSQL.</p></li>
            </ul>
        </li>
        <li><p><strong>Частичный индекс (Partial Index):</strong></p>
            <ul>
                <li><p>Индекс, созданный только для подмножества строк таблицы, удовлетворяющих определённому
                    условию.</p></li>
                <li><p>Полезен для оптимизации запросов, которые работают только с частью данных.</p></li>
                <li><p>Пример: <code>CREATE INDEX idx ON table (column) WHERE condition;</code>.</p></li>
            </ul>
        </li>
        <li><p><strong>Индекс по выражению (Expression Index):</strong></p>
            <ul>
                <li><p>Индекс, созданный на основе выражения или функции, применяемой к столбцу.</p></li>
                <li><p>Полезен для запросов, которые используют вычисляемые значения.</p></li>
                <li><p>Пример: <code>CREATE INDEX idx ON table (LOWER(column));</code>.</p></li>
            </ul>
        </li>
        <li><p><strong>Индекс покрытия (Covering Index):</strong></p>
            <ul>
                <li><p>Индекс, который содержит все столбцы, необходимые для выполнения запроса.</p></li>
                <li><p>Позволяет избежать чтения данных из таблицы, так как все необходимые данные уже содержатся в
                    индексе.</p></li>
                <li><p>Пример: индекс на <code>(col1, col2)</code> для запроса <code>SELECT col1, col2 FROM table WHERE
                    col1 = value</code>.</p></li>
            </ul>
        </li>
        <li><p><strong><a href="indexes_cluster.html">Кластеризованный индекс (Clustered Index)</a>:</strong></p>
            <ul>
                <li><p>Определяет физический порядок данных в таблице.</p></li>
                <li><p>В таблице может быть только один кластеризованный индекс.</p></li>
                <li><p>Пример: первичный ключ (Primary Key) в MySQL (InnoDB) автоматически создаёт кластеризованный
                    индекс.</p></li>
            </ul>
        </li>
        <li><p><strong>Некластеризованный индекс (Non-Clustered Index):</strong></p>
            <ul>
                <li><p>Не влияет на физический порядок данных в таблице.</p></li>
                <li><p>Содержит указатели на строки таблицы.</p></li>
                <li><p>В таблице может быть несколько некластеризованных индексов.</p></li>
            </ul>
        </li>
        <li><p><strong>Индекс по массиву (GIN — Generalized Inverted Index):</strong></p>
            <ul>
                <li><p>Используется для индексации составных данных, таких как массивы, JSON или полнотекстовые
                    данные.</p></li>
                <li><p>Поддерживает операции поиска по элементам массива или JSON-ключам.</p></li>
                <li><p>Пример: <code>CREATE INDEX idx ON table USING GIN (array_column);</code>.</p></li>
            </ul>
        </li>
        <li><p><strong>Индекс по R-дереву (R-Tree):</strong></p>
            <ul>
                <li><p>Используется для индексации многомерных данных, таких как геопространственные объекты.</p></li>
                <li><p>Поддерживает операции поиска по областям и расстояниям.</p></li>
            </ul>
        </li>
        <li><p><strong>BRIN (Block Range INdex):</strong></p>
            <ul>
                <li><p>Используется для больших таблиц с данными, которые имеют естественный порядок (например,
                    временные метки).</p></li>
                <li><p>Работает с блоками данных, что делает его компактным и эффективным для больших таблиц.</p></li>
                <li><p>Пример: <code>CREATE INDEX idx ON table USING BRIN (column);</code>.</p></li>
            </ul>
        </li>
    </ol>
    <hr>
    <h3><strong>Особенности индексов в разных СУБД</strong></h3>
    <ul>
        <li><p><strong>MySQL:</strong></p>
            <ul>
                <li><p>Поддерживает B-дерево, хэш-индекс (только для таблиц типа MEMORY), полнотекстовый индекс и
                    пространственный индекс.</p></li>
                <li><p>InnoDB использует кластеризованный индекс для первичного ключа.</p></li>
            </ul>
        </li>
        <li><p><strong>PostgreSQL:</strong></p>
            <ul>
                <li><p>Поддерживает B-дерево, хэш-индекс, GIN, GIST, BRIN, полнотекстовый индекс и пространственный
                    индекс.</p></li>
                <li><p>Позволяет создавать индексы по выражениям и частичные индексы.</p></li>
            </ul>
        </li>
        <li><p><strong>Oracle:</strong></p>
            <ul>
                <li><p>Поддерживает B-дерево, битовые индексы (Bitmap Index), функциональные индексы (Function-Based
                    Index) и пространственные индексы.</p></li>
            </ul>
        </li>
        <li><p><strong>SQL Server:</strong></p>
            <ul>
                <li><p>Поддерживает кластеризованные и некластеризованные индексы, полнотекстовый индекс,
                    пространственный индекс и индексы columnstore.</p></li>
            </ul>
        </li>
    </ul>
    <hr>
    <h3><strong>Когда использовать индексы</strong></h3>
    <ol start="1">
        <li><p><strong>Для ускорения поиска:</strong></p>
            <ul>
                <li><p>Если запросы часто фильтруют данные по определённым столбцам.</p></li>
            </ul>
        </li>
        <li><p><strong>Для ускорения сортировки и группировки:</strong></p>
            <ul>
                <li><p>Если запросы часто используют <code>ORDER BY</code> или <code>GROUP BY</code>.</p></li>
            </ul>
        </li>
        <li><p><strong>Для обеспечения уникальности:</strong></p>
            <ul>
                <li><p>Если необходимо гарантировать уникальность значений в столбце.</p></li>
            </ul>
        </li>
        <li><p><strong>Для работы с составными данными:</strong></p>
            <ul>
                <li><p>Если данные хранятся в виде массивов, JSON или геопространственных объектов.</p></li>
            </ul>
        </li>
    </ol>
    <hr>
    <h3><strong>Когда не использовать индексы</strong></h3>
    <ol start="1">
        <li><p><strong>На таблицах с частыми операциями вставки/обновления:</strong></p>
            <ul>
                <li><p>Индексы замедляют операции вставки и обновления, так как их необходимо поддерживать в актуальном
                    состоянии.</p></li>
            </ul>
        </li>
        <li><p><strong>На столбцах с низкой селективностью:</strong></p>
            <ul>
                <li><p>Если столбец содержит много повторяющихся значений (например, булевы значения), индекс может быть
                    неэффективным.</p></li>
            </ul>
        </li>
        <li><p><strong>На маленьких таблицах:</strong></p>
            <ul>
                <li><p>Полное сканирование маленькой таблицы может быть быстрее, чем использование индекса.</p></li>
            </ul>
        </li>
    </ol>
    <hr>
    <h3><strong>Заключение</strong></h3>
    <p>Правильное использование индексов — это ключ к оптимизации производительности базы данных. Выбор типа индекса
        зависит от структуры данных, типов запросов и особенностей СУБД. При создании индексов важно учитывать баланс
        между производительностью чтения и затратами на поддержку индексов при операциях записи.</p></div>
</body>
</html>