<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <link href="/../deepseek.css" rel="stylesheet">

</head>
<body>
<div class="ds-markdown ds-markdown--block" style="--ds-md-zoom: 1.143;"><p>GRASP (General Responsibility Assignment
    Software Patterns) — это набор принципов и паттернов, которые помогают в проектировании объектно-ориентированных
    систем. Они были предложены Крейгом Ларманом (Craig Larman) и направлены на помощь разработчикам в принятии решений
    о том, как распределять обязанности между классами и объектами в системе.</p>
    <p>Основная цель GRASP — обеспечить ясность, гибкость и поддерживаемость кода, а также помочь избежать
        распространенных ошибок в проектировании. Эти принципы не являются строгими правилами, а скорее руководствами,
        которые помогают принимать обоснованные решения.</p>
    <h3>Основные принципы GRASP:</h3>
    <ol start="1">
        <li><p><strong>Information Expert (Информационный эксперт)</strong></p>
            <ul>
                <li><p>Принцип гласит, что ответственность за выполнение задачи должна быть назначена тому классу,
                    который обладает всей необходимой информацией для её выполнения.</p></li>
                <li><p>Пример: если нужно рассчитать стоимость заказа, то класс <code>Order</code> должен отвечать за
                    эту задачу, так как он знает о товарах и их ценах.</p></li>
            </ul>
        </li>
        <li><p><strong>Creator (Создатель)</strong></p>
            <ul>
                <li><p>Класс, который должен создавать экземпляры другого класса, — это тот, который содержит или
                    агрегирует объекты этого класса, либо активно использует их.</p></li>
                <li><p>Пример: класс <code>Order</code> может создавать экземпляры класса <code>OrderItem</code>, так
                    как он содержит список товаров.</p></li>
            </ul>
        </li>
        <li><p><strong>Controller (Контроллер)</strong></p>
            <ul>
                <li><p>Ответственность за обработку системных событий или запросов должна быть назначена классу, который
                    представляет собой "фасад" для взаимодействия с системой.</p></li>
                <li><p>Пример: класс <code>OrderController</code> может обрабатывать запросы, связанные с созданием или
                    изменением заказов.</p></li>
            </ul>
        </li>
        <li><p><strong>Low Coupling (Низкая связанность)</strong></p>
            <ul>
                <li><p>Классы должны быть слабо связаны друг с другом, чтобы изменения в одном классе минимально влияли
                    на другие.</p></li>
                <li><p>Пример: вместо того чтобы напрямую зависеть от конкретной реализации базы данных, класс <code>OrderRepository</code>
                    может зависеть от интерфейса <code>IDatabase</code>.</p></li>
            </ul>
        </li>
        <li><p><strong>High Cohesion (Высокая связность)</strong></p>
            <ul>
                <li><p>Класс должен иметь четко определённые обязанности, и все его методы должны быть направлены на
                    выполнение этих обязанностей.</p></li>
                <li><p>Пример: класс <code>Order</code> должен отвечать только за управление заказами, а не за
                    логирование или отправку уведомлений.</p></li>
            </ul>
        </li>
        <li><p><strong>Polymorphism (Полиморфизм)</strong></p>
            <ul>
                <li><p>Используйте полиморфизм для обработки альтернативных вариантов поведения на основе типа
                    объекта.</p></li>
                <li><p>Пример: вместо использования условных операторов для обработки разных типов платежей, можно
                    создать интерфейс <code>PaymentMethod</code> и разные реализации для кредитной карты, PayPal и т.д.
                </p></li>
            </ul>
        </li>
        <li><p><strong>Pure Fabrication (Чистая выдумка)</strong></p>
            <ul>
                <li><p>Если ни один из существующих классов не подходит для выполнения определённой задачи, создайте
                    новый класс, который будет отвечать за эту задачу.</p></li>
                <li><p>Пример: класс <code>ReportGenerator</code> может быть создан для генерации отчётов, даже если он
                    не соответствует какой-либо предметной области.</p></li>
            </ul>
        </li>
        <li><p><strong>Indirection (Косвенность)</strong></p>
            <ul>
                <li><p>Используйте промежуточный объект для обеспечения слабой связанности между компонентами
                    системы.</p></li>
                <li><p>Пример: вместо того чтобы напрямую связывать класс <code>Order</code> с классом <code>PaymentProcessor</code>,
                    можно использовать интерфейс <code>IPaymentGateway</code>.</p></li>
            </ul>
        </li>
        <li><p><strong>Protected Variations (Защита от изменений)</strong></p>
            <ul>
                <li><p>Определите точки, где система может изменяться, и изолируйте их, чтобы минимизировать влияние
                    изменений на остальную часть системы.</p></li>
                <li><p>Пример: использование интерфейсов или абстрактных классов для защиты от изменений в
                    реализации.</p></li>
            </ul>
        </li>
    </ol>
    <h3>Преимущества использования GRASP:</h3>
    <ul>
        <li><p>Улучшает читаемость и поддерживаемость кода.</p></li>
        <li><p>Помогает избежать дублирования кода.</p></li>
        <li><p>Способствует созданию гибкой и расширяемой архитектуры.</p></li>
        <li><p>Упрощает тестирование и отладку.</p></li>
    </ul>
    <p>GRASP не является единственным подходом к проектированию, но он хорошо сочетается с другими методологиями, такими
        как SOLID, DDD (Domain-Driven Design) и паттерны проектирования (например, GoF).</p>
    <p>Если вы хотите глубже изучить GRASP, рекомендую обратиться к книге Крейга Лармана "Applying UML and Patterns",
        где эти принципы подробно разбираются.</p></div>
</body>
</html>
